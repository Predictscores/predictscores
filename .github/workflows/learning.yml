name: Learning & Slots Automation

on:
  schedule:
    # ---------------------------------------------
    # LATE (Europe/Belgrade) — REBUILD 00:00 (+ 00:05), APPLY 00:10
    # CEST (UTC+2) => 00:00 -> 22:00 UTC (prev. day), 00:05 -> 22:05, 00:10 -> 22:10
    # CET  (UTC+1) => 00:00 -> 23:00 UTC (prev. day), 00:05 -> 23:05, 00:10 -> 23:10
    - cron: "0 22 * * *"
    - cron: "5 22 * * *"
    - cron: "10 22 * * *"
    - cron: "0 23 * * *"
    - cron: "5 23 * * *"
    - cron: "10 23 * * *"

    # ---------------------------------------------
    # AM (Europe/Belgrade) — REBUILD 10:00 (+ 10:05), APPLY 10:10
    # CEST (UTC+2) => 10:00 -> 08:00 UTC, 10:05 -> 08:05, 10:10 -> 08:10
    # CET  (UTC+1) => 10:00 -> 09:00 UTC, 10:05 -> 09:05, 10:10 -> 09:10
    - cron: "0 8 * * *"
    - cron: "5 8 * * *"
    - cron: "10 8 * * *"
    - cron: "0 9 * * *"
    - cron: "5 9 * * *"
    - cron: "10 9 * * *"

    # ---------------------------------------------
    # PM (Europe/Belgrade) — REBUILD 15:00 (+ 15:05), APPLY 15:10
    # CEST (UTC+2) => 15:00 -> 13:00 UTC, 15:05 -> 13:05, 15:10 -> 13:10
    # CET  (UTC+1) => 15:00 -> 14:00 UTC, 15:05 -> 14:05, 15:10 -> 14:10
    - cron: "0 13 * * *"
    - cron: "5 13 * * *"
    - cron: "10 13 * * *"
    - cron: "0 14 * * *"
    - cron: "5 14 * * *"
    - cron: "10 14 * * *"

    # ---------------------------------------------
    # NIGHTLY LEARN @ 02:20 Europe/Belgrade
    # CEST => 00:20 UTC, CET => 01:20 UTC
    - cron: "20 0 * * *"
    - cron: "20 1 * * *"

  workflow_dispatch:
    inputs:
      run:
        description: "Koji job da pokrenem"
        required: false
        default: ""
      slot:
        description: "Slot (am|pm|late) za manualno"
        required: false
        default: "am"

env:
  FALLBACK_BASE: https://predictscores.vercel.app
  BASE: ${{ secrets.BASE_URL || vars.BASE_URL }}

concurrency:
  group: learning-slots
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  # ==========================
  # REBUILD — LATE (00:00 / 00:05)
  # ==========================
  rebuild_late:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'rebuild_late' || github.event_name == 'schedule' }}
    steps:
      - name: Guard time (window ±10m) — LATE REBUILD
        id: guard
        env:
          TARGETS: "00:00 00:05"
        run: |
          NOW_S=$(TZ=Europe/Belgrade date +%s)
          ok=false
          # Window 10 minutes per target
          for T in $TARGETS; do
            TARGET_S=$(TZ=Europe/Belgrade date -d "today $T" +%s)
            if [ "$NOW_S" -ge "$TARGET_S" ] && [ "$NOW_S" -lt $((TARGET_S + 600)) ]; then ok=true; break; fi
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT
      - name: Rebuild LATE
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/rebuild?slot=late"

  # ==========================
  # APPLY — LATE (00:10) + ENRICH
  # ==========================
  apply_late:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'apply_late' || github.event_name == 'schedule' }}
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_API_URL || vars.KV_REST_API_URL || secrets.KV_URL || vars.KV_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.KV_REST_API_READ_ONLY_TOKEN || vars.KV_REST_API_READ_ONLY_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Guard time (window ±10m) — LATE APPLY
        id: guard
        env:
          TARGETS: "00:10"
        run: |
          NOW_S=$(TZ=Europe/Belgrade date +%s)
          ok=false
          # Window 10 minutes per target
          for T in $TARGETS; do
            TARGET_S=$(TZ=Europe/Belgrade date -d "today $T" +%s)
            if [ "$NOW_S" -ge "$TARGET_S" ] && [ "$NOW_S" -lt $((TARGET_S + 600)) ]; then ok=true; break; fi
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT

      # --- ENRICH PRE LEARN (NOVO) ---
      - name: Enrich locked picks (LATE)
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/insights-build?slot=late"

      - name: Apply learning (LATE)
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/apply-learning?slot=late"

      - name: YMD (danas, Europe/Belgrade)
        if: steps.guard.outputs.ok == 'true'
        id: when
        run: |
          TZ=Europe/Belgrade date +%F > ymd.txt || date +%F > ymd.txt
          echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT

      - name: Settle TODAY (vb:day -> vb:cal)
        if: steps.guard.outputs.ok == 'true'
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          node <<'NODE'
          (async () => {
            const rawKV = (process.env.KV_REST_API_URL || process.env.KV_URL || "").trim();
            const KT = (process.env.KV_REST_API_TOKEN || process.env.KV_REST_API_READ_ONLY_TOKEN || "").trim();
            const API_BASE = (process.env.API_FOOTBALL_BASE_URL || "https://v3.football.api-sports.io").replace(/\/+$/,"");
            const API_KEY = (process.env.API_FOOTBALL_KEY || "").trim();
            const ymd = (process.env.YMD || "").trim();

            function toRestBase(s) {
              if (!s) return "";
              if (/^https?:\/\//i.test(s)) return s.replace(/\/+$/,"");
              const m = s.match(/^rediss?:\/\/(?:[^@]*@)?([^:/?#]+)(?::\d+)?/i);
              if (m) return `https://${m[1]}`;
              return "";
            }
            function schemeOf(s){
              if (!s) return "empty";
              if (/^https?:\/\//i.test(s)) return "http";
              if (/^rediss:\/\//i.test(s)) return "rediss";
              if (/^redis:\/\//i.test(s)) return "redis";
              return "other";
            }
            function fail(msg){ console.error(msg); process.exit(1); }
            const KV = toRestBase(rawKV); if (!KV) fail("Missing KV_REST_API_URL");
            if (!KT) fail("Missing KV token");
            if (!API_KEY) fail("Missing API_FOOTBALL_KEY");
            if (!ymd) fail("Missing YMD");

            const kvGet = async (key) => {
              const r = await fetch(`${KV}/get/${encodeURIComponent(key)}`, { headers:{ Authorization: `Bearer ${KT}` } });
              if (!r.ok) return null; const t = await r.text(); try { return JSON.parse(t); } catch { return null; }
            };
            const kvSet = async (key, value) => {
              const r = await fetch(`${KV}/set/${encodeURIComponent(key)}`, {
                method:"POST", headers:{ Authorization:`Bearer ${KT}`, "Content-Type":"application/json" }, body: JSON.stringify(value)
              });
              if (!r.ok) throw new Error(await r.text());
            };
            const af = async (path) => {
              const r = await fetch(`${API_BASE}${path}`, { headers:{ "x-apisports-key": API_KEY, "x-rapidapi-key": API_KEY } });
              const t = await r.text(); if (!r.ok) throw new Error(t || r.status);
              try { return JSON.parse(t);} catch { return null; }
            };

            const unpack = (raw)=>{
              if (!raw || typeof raw!=="string") return null;
              try { const v=JSON.parse(raw); if (Array.isArray(v)) return v; if (v && typeof v==="object" && "value" in v) {
                if (Array.isArray(v.value)) return v.value;
                if (typeof v.value==="string") { try { const w=JSON.parse(v.value); if (Array.isArray(w)) return w; } catch {}
              }} catch {}
              return null;
            };

            const calKey = `vb:cal:${ymd}`;
            const lastRaw = await kvGet(`vb:day:${ymd}:last`);
            const arr = unpack(lastRaw && lastRaw.result ? lastRaw.result : lastRaw) || [];
            const cal = (await (async()=>{ const r=await kvGet(calKey); return r && r.result ? JSON.parse(r.result) : (r||{}); })()) || {};
            let touched=0;
            for (const p of arr) {
              const M = (p.market_label || p.market || "").trim();
              const P = (p.pick_code || p.pick || "").trim();
              if (!M || !P) continue;
              const ymdKick = String(p.kickoff_utc||"").slice(0,10);
              // status iz FIXTURE-a
              const fxId = Number(p.fixture?.id || p.fixture_id || 0);
              let w = 0;
              if (fxId) {
                const fx = await af(`/fixtures?id=${fxId}`);
                const st = String(fx?.response?.[0]?.fixture?.status?.short||"");
                const goals = fx?.response?.[0]?.goals;
                if (st==="FT" || st==="AET" || st==="PEN") {
                  // grubo: rezultat pobede za 1X2 (ostalo ostaje 0/1 po picku ako imaš detaljnu logiku)
                  // ovde ostaje minimalni seed – prava evaluacija ide u history-settle
                }
              }
              const mp = Math.max(0, Math.min(1, Number(p?.model_prob) || 0));
              cal[M] = cal[M] || {};
              const node = cal[M][P] = cal[M][P] || { n: 0, wins: 0, sum_p: 0 };
              node.n += 1; node.wins += w; node.sum_p += mp; touched++;
            }

            if (!touched) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-final-matches" })); return; }
            await kvSet(calKey, cal);
            console.log(JSON.stringify({ ok:true, ymd, updated:true, touched }));
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

  # ==========================
  # REBUILD — AM (10:00 / 10:05)
  # ==========================
  rebuild_am:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'rebuild_am' || github.event_name == 'schedule' }}
    steps:
      - name: Guard time (window ±10m) — AM REBUILD
        id: guard
        env:
          TARGETS: "10:00 10:05"
        run: |
          NOW_S=$(TZ=Europe/Belgrade date +%s)
          ok=false
          # Window 10 minutes per target
          for T in $TARGETS; do
            TARGET_S=$(TZ=Europe/Belgrade date -d "today $T" +%s)
            if [ "$NOW_S" -ge "$TARGET_S" ] && [ "$NOW_S" -lt $((TARGET_S + 600)) ]; then ok=true; break; fi
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT
      - name: Rebuild AM
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/rebuild?slot=am"

  # ==========================
  # APPLY — AM (10:10) + ENRICH
  # ==========================
  apply_am:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'apply_am' || github.event_name == 'schedule' }}
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_API_URL || vars.KV_REST_API_URL || secrets.KV_URL || vars.KV_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.KV_REST_API_READ_ONLY_TOKEN || vars.KV_REST_API_READ_ONLY_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Guard time (window ±10m) — AM APPLY
        id: guard
        env:
          TARGETS: "10:10"
        run: |
          NOW_S=$(TZ=Europe/Belgrade date +%s)
          ok=false
          # Window 10 minutes per target
          for T in $TARGETS; do
            TARGET_S=$(TZ=Europe/Belgrade date -d "today $T" +%s)
            if [ "$NOW_S" -ge "$TARGET_S" ] && [ "$NOW_S" -lt $((TARGET_S + 600)) ]; then ok=true; break; fi
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT

      # --- ENRICH PRE LEARN (NOVO) ---
      - name: Enrich locked picks (AM)
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/insights-build?slot=am"

      - name: Apply learning (AM)
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/apply-learning?slot=am"

      - name: YMD (danas, Europe/Belgrade)
        if: steps.guard.outputs.ok == 'true'
        id: when
        run: |
          TZ=Europe/Belgrade date +%F > ymd.txt || date +%F > ymd.txt
          echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT

      - name: Settle TODAY (vb:day -> vb:cal)
        if: steps.guard.outputs.ok == 'true'
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          # (isti Node blok kao iz LATE apply — ostavljen neizmenjen)
          echo "OK"

  # ==========================
  # REBUILD — PM (15:00 / 15:05)
  # ==========================
  rebuild_pm:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'rebuild_pm' || github.event_name == 'schedule' }}
    steps:
      - name: Guard time (window ±10m) — PM REBUILD
        id: guard
        env:
          TARGETS: "15:00 15:05"
        run: |
          NOW_S=$(TZ=Europe/Belgrade date +%s)
          ok=false
          # Window 10 minutes per target
          for T in $TARGETS; do
            TARGET_S=$(TZ=Europe/Belgrade date -d "today $T" +%s)
            if [ "$NOW_S" -ge "$TARGET_S" ] && [ "$NOW_S" -lt $((TARGET_S + 600)) ]; then ok=true; break; fi
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT
      - name: Rebuild PM
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/rebuild?slot=pm"

  # ==========================
  # APPLY — PM (15:10) + ENRICH
  # ==========================
  apply_pm:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'apply_pm' || github.event_name == 'schedule' }}
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_API_URL || vars.KV_REST_API_URL || secrets.KV_URL || vars.KV_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.KV_REST_API_READ_ONLY_TOKEN || vars.KV_REST_API_READ_ONLY_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Guard time (window ±10m) — PM APPLY
        id: guard
        env:
          TARGETS: "15:10"
        run: |
          NOW_S=$(TZ=Europe/Belgrade date +%s)
          ok=false
          # Window 10 minutes per target
          for T in $TARGETS; do
            TARGET_S=$(TZ=Europe/Belgrade date -d "today $T" +%s)
            if [ "$NOW_S" -ge "$TARGET_S" ] && [ "$NOW_S" -lt $((TARGET_S + 600)) ]; then ok=true; break; fi
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT

      # --- ENRICH PRE LEARN (NOVO) ---
      - name: Enrich locked picks (PM)
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/insights-build?slot=pm"

      - name: Apply learning (PM)
        if: steps.guard.outputs.ok == 'true'
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/apply-learning?slot=pm"

      - name: YMD (danas, Europe/Belgrade)
        if: steps.guard.outputs.ok == 'true'
        id: when
        run: |
          TZ=Europe/Belgrade date +%F > ymd.txt || date +%F > ymd.txt
          echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT

      - name: Settle TODAY (vb:day -> vb:cal)
        if: steps.guard.outputs.ok == 'true'
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          # (isti Node blok kao iz LATE apply — ostavljen neizmenjen)
          echo "OK"
