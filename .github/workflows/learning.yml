name: Learning & Slots Automation

on:
  schedule:
    # REBUILD slotova (UTC)
    - cron: "55 8 * * *"   # ≈ 10:55 Belgrade (AM)
    - cron: "55 13 * * *"  # ≈ 15:55 Belgrade (PM)
    - cron: "55 20 * * *"  # ≈ 22:55 Belgrade (LATE)
    # APPLY-LEARNING 5 min posle svakog REBUILD-a (UTC) — SETTLE za TEKUĆI dan
    - cron: "0 9 * * *"    # ≈ 11:00 Belgrade (AM apply)
    - cron: "0 14 * * *"   # ≈ 16:00 Belgrade (PM apply)
    - cron: "0 21 * * *"   # ≈ 23:00 Belgrade (LATE apply)
    # NIGHTLY LEARN (UTC) — SETTLE za JUČE
    - cron: "20 0 * * *"   # ≈ 02:20 Belgrade
  workflow_dispatch:
    inputs:
      run:
        description: "Koji job da pokrenem"
        type: choice
        required: true
        options:
          - rebuild_am
          - rebuild_pm
          - rebuild_late
          - apply_am
          - apply_pm
          - apply_late
          - nightly_learn
          - settle_today_all
          - settle_custom
        default: settle_today_all
      ymd:
        description: "Datum za settle (YYYY-MM-DD). Koristi se kad je run=settle_custom"
        required: false
        type: string

env:
  BASE: ${{ secrets.BASE_URL || vars.BASE_URL }}
  FALLBACK_BASE: https://predictscores.vercel.app
  LEARN_MINN: 10
  LEARN_Q: 0.35

concurrency:
  group: learning-slots
  cancel-in-progress: true

jobs:
  # -------------------------
  # REBUILD — AM
  # -------------------------
  rebuild_am:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '55 8 * * *') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'rebuild_am') }}
    runs-on: ubuntu-latest
    steps:
      - name: Rebuild AM
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/rebuild?slot=am"

  # -------------------------
  # REBUILD — PM
  # -------------------------
  rebuild_pm:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '55 13 * * *') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'rebuild_pm') }}
    runs-on: ubuntu-latest
    steps:
      - name: Rebuild PM
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/rebuild?slot=pm"

  # -------------------------
  # REBUILD — LATE
  # -------------------------
  rebuild_late:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '55 20 * * *') || (github.event_name == 'workflow_dispatch' && github.event.inputs.run == 'rebuild_late') }}
    runs-on: ubuntu-latest
    steps:
      - name: Rebuild LATE
        run: |
          set -euo pipefail
          B="${BASE:-$FALLBACK_BASE}"
          curl -fsS "$B/api/cron/rebuild?slot=late"

  # -------------------------
  # APPLY-LEARNING — AM (SETTLE TODAY)
  # -------------------------
  apply_am:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '0 9 * * *') || (github.event_name == 'workflow_dispatch' && (github.event.inputs.run == 'apply_am' || github.event.inputs.run == 'settle_today_all')) }}
    runs-on: ubuntu-latest
    environment: production   # <-- promeni ako ti je environment drugo ime
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_URL || vars.KV_REST_URL || secrets.KV_REST_API_URL || vars.KV_REST_API_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.UPSTASH_REDIS_REST_TOKEN || vars.UPSTASH_REDIS_REST_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Sanity env
        run: |
          [ -n "${KV_REST_API_URL:-}" ] && echo "KV_REST_API_URL: SET" || echo "KV_REST_API_URL: MISSING"
          [ -n "${KV_REST_API_TOKEN:-}" ] && echo "KV_REST_API_TOKEN: SET" || echo "KV_REST_API_TOKEN: MISSING"
          [ -n "${API_FOOTBALL_KEY:-}" ] && echo "API_FOOTBALL_KEY: SET" || echo "API_FOOTBALL_KEY: MISSING"

      - name: Izračunaj YMD (danas u Europe/Belgrade)
        id: when
        run: |
          TZ=Europe/Belgrade date +%F > ymd.txt || date +%F > ymd.txt
          echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT

      - name: Settle TODAY (može biti no-op)
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          node <<'NODE'
          (async () => {
            const KV = (process.env.KV_REST_API_URL || process.env.KV_REST_URL || process.env.UPSTASH_REDIS_REST_URL || "").trim();
            const KT = (process.env.KV_REST_API_TOKEN || process.env.UPSTASH_REDIS_REST_TOKEN || "").trim();
            const API_BASE = (process.env.API_FOOTBALL_BASE_URL || "https://v3.football.api-sports.io").replace(/\/+$/,"");
            const API_KEY = (process.env.API_FOOTBALL_KEY || "").trim();
            const ymd = (process.env.YMD || "").trim();

            function fail(msg){ console.error(msg); process.exit(1); }
            if (!KV || !KT) fail("Missing KV_REST_API_URL/KV_REST_URL or KV token");
            if (!API_KEY) fail("Missing API_FOOTBALL_KEY");
            if (!ymd) fail("Missing YMD");

            const kvGet = async (key) => {
              const r = await fetch(`${KV}/get/${encodeURIComponent(key)}`, { headers:{ Authorization: `Bearer ${KT}` } });
              if (!r.ok) return null; const text = await r.text(); try { return JSON.parse(text); } catch { return null; }
            };
            const kvSet = async (key, value) => {
              const r = await fetch(`${KV}/set/${encodeURIComponent(key)}`, {
                method:"POST", headers:{ Authorization:`Bearer ${KT}`, "Content-Type":"application/json" }, body: JSON.stringify(value)
              });
              if (!r.ok) throw new Error(await r.text());
            };
            const af = async (path) => {
              const r = await fetch(`${API_BASE}${path}`, { headers:{ "x-apisports-key": API_KEY, "x-rapidapi-key": API_KEY } });
              const text = await r.text(); if (!r.ok) throw new Error(text || r.statusText); return JSON.parse(text);
            };
            const win = (market, pick, gh, ga) => {
              if (!Number.isFinite(gh) || !Number.isFinite(ga)) return null;
              if (market === "1X2") { if (pick === "1") return gh > ga ? 1 : 0; if (pick === "X") return gh === ga ? 1 : 0; if (pick === "2") return ga > gh ? 1 : 0; }
              if (market === "BTTS") { const b = (gh > 0 && ga > 0); return pick === "Y" ? (b ? 1 : 0) : (b ? 0 : 1); }
              if (market === "OU2.5") { const over = (gh + ga) >= 3; return pick === "O2.5" ? (over ? 1 : 0) : (over ? 0 : 1); }
              return null; // HT-FT ne kalibrišemo
            };

            const unionKey = `vb:day:${ymd}:union`;
            const union = await kvGet(unionKey) || [];
            if (!Array.isArray(union) || union.length === 0) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-picks" })); return; }

            const fj = await af(`/fixtures?date=${encodeURIComponent(ymd)}`);
            const map = new Map();
            for (const r of (fj.response || [])) {
              const id = r?.fixture?.id; if (!id) continue;
              map.set(id, { gh: Number(r?.goals?.home), ga: Number(r?.goals?.away), st: String(r?.fixture?.status?.short || "").toUpperCase() });
            }

            const calKey = "vb:cal:v1";
            const cal = await kvGet(calKey) || {};
            let touched = 0;

            for (const p of union) {
              const r = map.get(p?.fixture_id); if (!r) continue;
              if (!/^FT|AET|PEN$/.test(r.st || "")) continue;
              const M = String(p?.market || "").toUpperCase();
              const P = String(p?.pick_code || "").toUpperCase();
              const w = win(M, P, r.gh, r.ga); if (w == null) continue;
              const mp = Math.max(0, Math.min(1, Number(p?.model_prob) || 0));
              cal[M] = cal[M] || {};
              const node = cal[M][P] = cal[M][P] || { n: 0, wins: 0, sum_p: 0 };
              node.n += 1; node.wins += w; node.sum_p += mp; touched++;
            }

            if (!touched) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-final-matches" })); return; }
            await kvSet(calKey, cal);
            console.log(JSON.stringify({ ok:true, ymd, updated:true, touched }));
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

  # -------------------------
  # APPLY-LEARNING — PM (SETTLE TODAY)
  # -------------------------
  apply_pm:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '0 14 * * *') || (github.event_name == 'workflow_dispatch' && (github.event.inputs.run == 'apply_pm' || github.event.inputs.run == 'settle_today_all')) }}
    runs-on: ubuntu-latest
    environment: production
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_URL || vars.KV_REST_URL || secrets.KV_REST_API_URL || vars.KV_REST_API_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.UPSTASH_REDIS_REST_TOKEN || vars.UPSTASH_REDIS_REST_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Sanity env
        run: |
          [ -n "${KV_REST_API_URL:-}" ] && echo "KV_REST_API_URL: SET" || echo "KV_REST_API_URL: MISSING"
          [ -n "${KV_REST_API_TOKEN:-}" ] && echo "KV_REST_API_TOKEN: SET" || echo "KV_REST_API_TOKEN: MISSING"
          [ -n "${API_FOOTBALL_KEY:-}" ] && echo "API_FOOTBALL_KEY: SET" || echo "API_FOOTBALL_KEY: MISSING"

      - name: Izračunaj YMD (danas u Europe/Belgrade)
        id: when
        run: |
          TZ=Europe/Belgrade date +%F > ymd.txt || date +%F > ymd.txt
          echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT

      - name: Settle TODAY (može biti no-op)
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          node <<'NODE'
          (async () => {
            const KV = (process.env.KV_REST_API_URL || process.env.KV_REST_URL || process.env.UPSTASH_REDIS_REST_URL || "").trim();
            const KT = (process.env.KV_REST_API_TOKEN || process.env.UPSTASH_REDIS_REST_TOKEN || "").trim();
            const API_BASE = (process.env.API_FOOTBALL_BASE_URL || "https://v3.football.api-sports.io").replace(/\/+$/,"");
            const API_KEY = (process.env.API_FOOTBALL_KEY || "").trim();
            const ymd = (process.env.YMD || "").trim();

            function fail(msg){ console.error(msg); process.exit(1); }
            if (!KV || !KT) fail("Missing KV_REST_API_URL/KV_REST_URL or KV token");
            if (!API_KEY) fail("Missing API_FOOTBALL_KEY");
            if (!ymd) fail("Missing YMD");

            const kvGet = async (key) => {
              const r = await fetch(`${KV}/get/${encodeURIComponent(key)}`, { headers:{ Authorization: `Bearer ${KT}` } });
              if (!r.ok) return null; const text = await r.text(); try { return JSON.parse(text); } catch { return null; }
            };
            const kvSet = async (key, value) => {
              const r = await fetch(`${KV}/set/${encodeURIComponent(key)}`, {
                method:"POST", headers:{ Authorization:`Bearer ${KT}`, "Content-Type":"application/json" }, body: JSON.stringify(value)
              });
              if (!r.ok) throw new Error(await r.text());
            };
            const af = async (path) => {
              const r = await fetch(`${API_BASE}${path}`, { headers:{ "x-apisports-key": API_KEY, "x-rapidapi-key": API_KEY } });
              const text = await r.text(); if (!r.ok) throw new Error(text || r.statusText); return JSON.parse(text);
            };
            const win = (market, pick, gh, ga) => {
              if (!Number.isFinite(gh) || !Number.isFinite(ga)) return null;
              if (market === "1X2") { if (pick === "1") return gh > ga ? 1 : 0; if (pick === "X") return gh === ga ? 1 : 0; if (pick === "2") return ga > gh ? 1 : 0; }
              if (market === "BTTS") { const b = (gh > 0 && ga > 0); return pick === "Y" ? (b ? 1 : 0) : (b ? 0 : 1); }
              if (market === "OU2.5") { const over = (gh + ga) >= 3; return pick === "O2.5" ? (over ? 1 : 0) : (over ? 0 : 1); }
              return null;
            };

            const unionKey = `vb:day:${ymd}:union`;
            const union = await kvGet(unionKey) || [];
            if (!Array.isArray(union) || union.length === 0) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-picks" })); return; }

            const fj = await af(`/fixtures?date=${encodeURIComponent(ymd)}`);
            const map = new Map();
            for (const r of (fj.response || [])) {
              const id = r?.fixture?.id; if (!id) continue;
              map.set(id, { gh: Number(r?.goals?.home), ga: Number(r?.goals?.away), st: String(r?.fixture?.status?.short || "").toUpperCase() });
            }

            const calKey = "vb:cal:v1";
            const cal = await kvGet(calKey) || {};
            let touched = 0;

            for (const p of union) {
              const r = map.get(p?.fixture_id); if (!r) continue;
              if (!/^FT|AET|PEN$/.test(r.st || "")) continue;
              const M = String(p?.market || "").toUpperCase();
              const P = String(p?.pick_code || "").toUpperCase();
              const w = win(M, P, r.gh, r.ga); if (w == null) continue;
              const mp = Math.max(0, Math.min(1, Number(p?.model_prob) || 0));
              cal[M] = cal[M] || {};
              const node = cal[M][P] = cal[M][P] || { n: 0, wins: 0, sum_p: 0 };
              node.n += 1; node.wins += w; node.sum_p += mp; touched++;
            }

            if (!touched) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-final-matches" })); return; }
            await kvSet(calKey, cal);
            console.log(JSON.stringify({ ok:true, ymd, updated:true, touched }));
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

  # -------------------------
  # APPLY-LEARNING — LATE (SETTLE TODAY)
  # -------------------------
  apply_late:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '0 21 * * *') || (github.event_name == 'workflow_dispatch' && (github.event.inputs.run == 'apply_late' || github.event.inputs.run == 'settle_today_all')) }}
    runs-on: ubuntu-latest
    environment: production
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_URL || vars.KV_REST_URL || secrets.KV_REST_API_URL || vars.KV_REST_API_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.UPSTASH_REDIS_REST_TOKEN || vars.UPSTASH_REDIS_REST_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Sanity env
        run: |
          [ -n "${KV_REST_API_URL:-}" ] && echo "KV_REST_API_URL: SET" || echo "KV_REST_API_URL: MISSING"
          [ -n "${KV_REST_API_TOKEN:-}" ] && echo "KV_REST_API_TOKEN: SET" || echo "KV_REST_API_TOKEN: MISSING"
          [ -n "${API_FOOTBALL_KEY:-}" ] && echo "API_FOOTBALL_KEY: SET" || echo "API_FOOTBALL_KEY: MISSING"

      - name: Izračunaj YMD (danas u Europe/Belgrade)
        id: when
        run: |
          TZ=Europe/Belgrade date +%F > ymd.txt || date +%F > ymd.txt
          echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT

      - name: Settle TODAY (može biti no-op)
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          node <<'NODE'
          (async () => {
            const KV = (process.env.KV_REST_API_URL || process.env.KV_REST_URL || process.env.UPSTASH_REDIS_REST_URL || "").trim();
            const KT = (process.env.KV_REST_API_TOKEN || process.env.UPSTASH_REDIS_REST_TOKEN || "").trim();
            const API_BASE = (process.env.API_FOOTBALL_BASE_URL || "https://v3.football.api-sports.io").replace(/\/+$/,"");
            const API_KEY = (process.env.API_FOOTBALL_KEY || "").trim();
            const ymd = (process.env.YMD || "").trim();

            function fail(msg){ console.error(msg); process.exit(1); }
            if (!KV || !KT) fail("Missing KV_REST_API_URL/KV_REST_URL or KV token");
            if (!API_KEY) fail("Missing API_FOOTBALL_KEY");
            if (!ymd) fail("Missing YMD");

            const kvGet = async (key) => {
              const r = await fetch(`${KV}/get/${encodeURIComponent(key)}`, { headers:{ Authorization: `Bearer ${KT}` } });
              if (!r.ok) return null; const text = await r.text(); try { return JSON.parse(text); } catch { return null; }
            };
            const kvSet = async (key, value) => {
              const r = await fetch(`${KV}/set/${encodeURIComponent(key)}`, {
                method:"POST", headers:{ Authorization:`Bearer ${KT}`, "Content-Type":"application/json" }, body: JSON.stringify(value)
              });
              if (!r.ok) throw new Error(await r.text());
            };
            const af = async (path) => {
              const r = await fetch(`${API_BASE}${path}`, { headers:{ "x-apisports-key": API_KEY, "x-rapidapi-key": API_KEY } });
              const text = await r.text(); if (!r.ok) throw new Error(text || r.statusText); return JSON.parse(text);
            };
            const win = (market, pick, gh, ga) => {
              if (!Number.isFinite(gh) || !Number.isFinite(ga)) return null;
              if (market === "1X2") { if (pick === "1") return gh > ga ? 1 : 0; if (pick === "X") return gh === ga ? 1 : 0; if (pick === "2") return ga > gh ? 1 : 0; }
              if (market === "BTTS") { const b = (gh > 0 && ga > 0); return pick === "Y" ? (b ? 1 : 0) : (b ? 0 : 1); }
              if (market === "OU2.5") { const over = (gh + ga) >= 3; return pick === "O2.5" ? (over ? 1 : 0) : (over ? 0 : 1); }
              return null;
            };

            const unionKey = `vb:day:${ymd}:union`;
            const union = await kvGet(unionKey) || [];
            if (!Array.isArray(union) || union.length === 0) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-picks" })); return; }

            const fj = await af(`/fixtures?date=${encodeURIComponent(ymd)}`);
            const map = new Map();
            for (const r of (fj.response || [])) {
              const id = r?.fixture?.id; if (!id) continue;
              map.set(id, { gh: Number(r?.goals?.home), ga: Number(r?.goals?.away), st: String(r?.fixture?.status?.short || "").toUpperCase() });
            }

            const calKey = "vb:cal:v1";
            const cal = await kvGet(calKey) || {};
            let touched = 0;

            for (const p of union) {
              const r = map.get(p?.fixture_id); if (!r) continue;
              if (!/^FT|AET|PEN$/.test(r.st || "")) continue;
              const M = String(p?.market || "").toUpperCase();
              const P = String(p?.pick_code || "").toUpperCase();
              const w = win(M, P, r.gh, r.ga); if (w == null) continue;
              const mp = Math.max(0, Math.min(1, Number(p?.model_prob) || 0));
              cal[M] = cal[M] || {};
              const node = cal[M][P] = cal[M][P] || { n: 0, wins: 0, sum_p: 0 };
              node.n += 1; node.wins += w; node.sum_p += mp; touched++;
            }

            if (!touched) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-final-matches" })); return; }
            await kvSet(calKey, cal);
            console.log(JSON.stringify({ ok:true, ymd, updated:true, touched }));
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

  # -------------------------
  # NIGHTLY LEARN — SETTLE YESTERDAY (ili custom)
  # -------------------------
  nightly_learn:
    if: ${{ (github.event_name == 'schedule' && github.event.schedule == '20 0 * * *') || (github.event_name == 'workflow_dispatch' && (github.event.inputs.run == 'nightly_learn' || github.event.inputs.run == 'settle_custom')) }}
    runs-on: ubuntu-latest
    environment: production
    env:
      KV_REST_API_URL: ${{ secrets.KV_REST_URL || vars.KV_REST_URL || secrets.KV_REST_API_URL || vars.KV_REST_API_URL }}
      KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN || vars.KV_REST_API_TOKEN || secrets.UPSTASH_REDIS_REST_TOKEN || vars.UPSTASH_REDIS_REST_TOKEN }}
      API_FOOTBALL_KEY: ${{ secrets.API_FOOTBALL_KEY || vars.API_FOOTBALL_KEY }}
      API_FOOTBALL_BASE_URL: ${{ secrets.API_FOOTBALL_BASE_URL || vars.API_FOOTBALL_BASE_URL }}
    steps:
      - name: Sanity env
        run: |
          [ -n "${KV_REST_API_URL:-}" ] && echo "KV_REST_API_URL: SET" || echo "KV_REST_API_URL: MISSING"
          [ -n "${KV_REST_API_TOKEN:-}" ] && echo "KV_REST_API_TOKEN: SET" || echo "KV_REST_API_TOKEN: MISSING"
          [ -n "${API_FOOTBALL_KEY:-}" ] && echo "API_FOOTBALL_KEY: SET" || echo "API_FOOTBALL_KEY: MISSING"

      - name: Izračunaj YMD
        id: when
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.run }}" = "settle_custom" ] && [ -n "${{ github.event.inputs.ymd }}" ]; then
            echo "ymd=${{ github.event.inputs.ymd }}" >> $GITHUB_OUTPUT
          else
            TZ=Europe/Belgrade date -d "yesterday" +%F > ymd.txt || date -v-1d +%F > ymd.txt
            echo "ymd=$(cat ymd.txt)" >> $GITHUB_OUTPUT
          fi

      - name: Settle (vb:day:$YMD:union -> vb:cal:v1)
        env:
          YMD: ${{ steps.when.outputs.ymd }}
        run: |
          node <<'NODE'
          (async () => {
            const KV = (process.env.KV_REST_API_URL || process.env.KV_REST_URL || process.env.UPSTASH_REDIS_REST_URL || "").trim();
            const KT = (process.env.KV_REST_API_TOKEN || process.env.UPSTASH_REDIS_REST_TOKEN || "").trim();
            const API_BASE = (process.env.API_FOOTBALL_BASE_URL || "https://v3.football.api-sports.io").replace(/\/+$/,"");
            const API_KEY = (process.env.API_FOOTBALL_KEY || "").trim();
            const ymd = (process.env.YMD || "").trim();

            function fail(msg){ console.error(msg); process.exit(1); }
            if (!KV || !KT) fail("Missing KV_REST_API_URL/KV_REST_URL or KV token");
            if (!API_KEY) fail("Missing API_FOOTBALL_KEY");
            if (!ymd) fail("Missing YMD");

            const kvGet = async (key) => {
              const r = await fetch(`${KV}/get/${encodeURIComponent(key)}`, { headers:{ Authorization: `Bearer ${KT}` } });
              if (!r.ok) return null; const text = await r.text(); try { return JSON.parse(text); } catch { return null; }
            };
            const kvSet = async (key, value) => {
              const r = await fetch(`${KV}/set/${encodeURIComponent(key)}`, {
                method:"POST", headers:{ Authorization:`Bearer ${KT}`, "Content-Type":"application/json" }, body: JSON.stringify(value)
              });
              if (!r.ok) throw new Error(await r.text());
            };
            const af = async (path) => {
              const r = await fetch(`${API_BASE}${path}`, { headers:{ "x-apisports-key": API_KEY, "x-rapidapi-key": API_KEY } });
              const text = await r.text(); if (!r.ok) throw new Error(text || r.statusText); return JSON.parse(text);
            };
            const win = (market, pick, gh, ga) => {
              if (!Number.isFinite(gh) || !Number.isFinite(ga)) return null;
              if (market === "1X2") { if (pick === "1") return gh > ga ? 1 : 0; if (pick === "X") return gh === ga ? 1 : 0; if (pick === "2") return ga > gh ? 1 : 0; }
              if (market === "BTTS") { const b = (gh > 0 && ga > 0); return pick === "Y" ? (b ? 1 : 0) : (b ? 0 : 1); }
              if (market === "OU2.5") { const over = (gh + ga) >= 3; return pick === "O2.5" ? (over ? 1 : 0) : (over ? 0 : 1); }
              return null; // HT-FT ne kalibrišemo
            };

            const unionKey = `vb:day:${ymd}:union`;
            const union = await kvGet(unionKey) || [];
            if (!Array.isArray(union) || union.length === 0) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-picks" })); return; }

            const fj = await af(`/fixtures?date=${encodeURIComponent(ymd)}`);
            const map = new Map();
            for (const r of (fj.response || [])) {
              const id = r?.fixture?.id; if (!id) continue;
              map.set(id, { gh: Number(r?.goals?.home), ga: Number(r?.goals?.away), st: String(r?.fixture?.status?.short || "").toUpperCase() });
            }

            const calKey = "vb:cal:v1";
            const cal = await kvGet(calKey) || {};
            let touched = 0;

            for (const p of union) {
              const r = map.get(p?.fixture_id); if (!r) continue;
              if (!/^FT|AET|PEN$/.test(r.st || "")) continue;
              const M = String(p?.market || "").toUpperCase();
              const P = String(p?.pick_code || "").toUpperCase();
              const w = win(M, P, r.gh, r.ga); if (w == null) continue;
              const mp = Math.max(0, Math.min(1, Number(p?.model_prob) || 0));
              cal[M] = cal[M] || {};
              const node = cal[M][P] = cal[M][P] || { n: 0, wins: 0, sum_p: 0 };
              node.n += 1; node.wins += w; node.sum_p += mp; touched++;
            }

            if (!touched) { console.log(JSON.stringify({ ok:true, ymd, updated:false, reason:"no-final-matches" })); return; }
            await kvSet(calKey, cal);
            console.log(JSON.stringify({ ok:true, ymd, updated:true, touched }));
          })().catch(e => { console.error(e); process.exit(1); });
          NODE
